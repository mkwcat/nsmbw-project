#pragma once

#include <algorithm>
#include <cassert>
#include <ios>

namespace std
{

template <class CharT>
class char_traits;

template <>
class char_traits<char>
{
public:
    // Type Aliases
    // ^^^^^^

    using char_type = char;
    using int_type = int;
    using off_type = std::streamoff;
    using pos_type = std::streampos;

public:
    // Static Methods
    // ^^^^^^

    constexpr static void assign(char_type& r, const char_type& a)
    {
        r = a;
    }

    constexpr static bool eq(const char_type& a, const char_type& b)
    {
        return a == b;
    }

    constexpr static bool lt(const char_type& a, const char_type& b)
    {
        return a < b;
    }

    constexpr static int compare(const char_type* s1, const char_type* s2, std::size_t n)
    {
        for (std::size_t i = 0; i < n; i++) {
            if (lt(s1[i], s2[i])) {
                return -1;
            }
            if (lt(s2[i], s1[i])) {
                return 1;
            }
        }
        return 0;
    }

    constexpr static std::size_t length(const char_type* s)
    {
        std::size_t len = 0;
        while (s[len] != '\0') {
            len++;
        }
        return len;
    }

    constexpr static const char_type* find(const char_type* s, std::size_t n, const char_type& a)
    {
        for (std::size_t i = 0; i < n; i++) {
            if (eq(s[i], a)) {
                return &s[i];
            }
        }
        return nullptr;
    }

    constexpr static char_type to_char_type(const int_type& c)
    {
        return static_cast<char_type>(c);
    }

    constexpr static int_type to_int_type(const char_type& c)
    {
        return static_cast<int_type>(c);
    }

    constexpr static bool eq_int_type(const int_type& a, const int_type& b)
    {
        return a == b;
    }

    constexpr static int_type eof()
    {
        return -1;
    }

    constexpr static int_type not_eof(const int_type& c)
    {
        return eq_int_type(c, eof()) ? 0 : c;
    }
};

template <class CharT, class Traits = std::char_traits<CharT>>
class basic_string_view
{
public:
    // Type Aliases
    // ^^^^^^

    using traits_type = Traits;
    using value_type = CharT;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using reference = value_type&;
    using const_reference = const value_type&;
    using pointer = const value_type*;
    using const_pointer = const value_type*;

public:
    // Constants
    // ^^^^^^

    static constexpr size_type npos = static_cast<size_type>(-1);

public:
    // Structors
    // ^^^^^^

    constexpr basic_string_view() noexcept
      : m_str(nullptr)
      , m_size(0)
    {
    }

    constexpr basic_string_view(const value_type* s, size_type count) noexcept
      : m_str(s)
      , m_size(count)
    {
    }

    constexpr basic_string_view(const value_type* s) noexcept
      : m_str(s)
      , m_size(traits_type::length(s))
    {
    }

public:
    // Instance Methods
    // ^^^^^^

    // Element access

    constexpr const_reference at(size_type pos) const
    {
        assert(pos < m_size);
        return m_str[pos];
    }

    constexpr const_reference front() const
    {
        return at(0);
    }

    constexpr const_reference back() const
    {
        return at(m_size - 1);
    }

    constexpr const_pointer data() const noexcept
    {
        return m_str;
    }

    // Capacity

    constexpr size_type size() const noexcept
    {
        return m_size;
    }

    constexpr size_type length() const noexcept
    {
        return m_size;
    }

    constexpr size_type max_size() const noexcept
    {
        return npos;
    }

    constexpr bool empty() const noexcept
    {
        return m_size == 0;
    }

    // Modifiers

    constexpr void remove_prefix(size_type n) noexcept
    {
        if (n > m_size) {
            n = m_size;
        }
        m_str += n;
        m_size -= n;
    }

    constexpr void remove_suffix(size_type n) noexcept
    {
        if (n > m_size) {
            n = m_size;
        }
        m_size -= n;
    }

    constexpr void swap(basic_string_view& other) noexcept
    {
        const_pointer temp_str = m_str;
        size_type temp_size = m_size;
        m_str = other.m_str;
        m_size = other.m_size;
        other.m_str = temp_str;
        other.m_size = temp_size;
    }

    // Operations

    // TODO: copy

    constexpr basic_string_view substr(size_type pos = 0, size_type count = npos) const
    {
        assert(pos <= m_size);
        if (count == npos || pos + count > m_size) {
            count = m_size - pos;
        }
        return basic_string_view(m_str + pos, count);
    }

    constexpr int compare(basic_string_view v) const noexcept
    {
        const size_type rlen = std::min(m_size, v.m_size);
        int result = traits_type::compare(m_str, v.m_str, rlen);
        if (result != 0) {
            return result;
        }
        if (m_size == v.m_size) {
            return 0;
        }
        return m_size < v.m_size ? -1 : 1;
    }

    constexpr int compare(size_type pos1, size_type count1, basic_string_view v) const
    {
        return substr(pos1, count1).compare(v);
    }

    constexpr int compare(
      size_type pos1, size_type count1, basic_string_view v, size_type pos2, size_type count2
    ) const
    {
        return substr(pos1, count1).compare(v.substr(pos2, count2));
    }

    constexpr int compare(const CharT* s) const
    {
        return compare(basic_string_view(s));
    }

    constexpr int compare(size_type pos1, size_type count1, const CharT* s) const
    {
        return substr(pos1, count1).compare(basic_string_view(s));
    }

    constexpr int compare(size_type pos1, size_type count1, const CharT* s, size_type count2) const
    {
        return substr(pos1, count1).compare(basic_string_view(s, count2));
    }

    constexpr bool starts_with(basic_string_view sv) const noexcept
    {
        return m_size >= sv.m_size && traits_type::compare(m_str, sv.m_str, sv.m_size) == 0;
    }

    constexpr bool starts_with(CharT c) const noexcept
    {
        return !empty() && traits_type::eq(m_str[0], c);
    }

    constexpr bool starts_with(const CharT* s) const
    {
        return starts_with(basic_string_view(s));
    }

    constexpr bool ends_with(basic_string_view sv) const noexcept
    {
        return m_size >= sv.m_size &&
               traits_type::compare(m_str + m_size - sv.m_size, sv.m_str, sv.m_size) == 0;
    }

    constexpr bool ends_with(CharT ch) const noexcept
    {
        return !empty() && traits_type::eq(m_str[m_size - 1], ch);
    }

    constexpr bool ends_with(const CharT* s) const
    {
        return ends_with(basic_string_view(s));
    }

    constexpr bool contains(basic_string_view sv) const noexcept
    {
        return find(sv) != npos;
    }

    constexpr bool contains(CharT c) const noexcept
    {
        return find(c) != npos;
    }

    constexpr bool contains(const CharT* s) const
    {
        return contains(basic_string_view(s));
    }

    constexpr size_type find(const basic_string_view& sv, size_type pos = 0) const noexcept
    {
        if (sv.m_size == 0) {
            return pos <= m_size ? pos : npos;
        }
        if (sv.m_size > m_size || pos > m_size - sv.m_size) {
            return npos;
        }
        for (size_type i = pos; i <= m_size - sv.m_size; i++) {
            if (traits_type::compare(m_str + i, sv.m_str, sv.m_size) == 0) {
                return i;
            }
        }
        return npos;
    }

    constexpr size_type find(const value_type& c, size_type pos = 0) const noexcept
    {
        if (pos >= m_size) {
            return npos;
        }
        const_pointer result = traits_type::find(m_str + pos, m_size - pos, c);
        if (result != nullptr) {
            return static_cast<size_type>(result - m_str);
        }
        return npos;
    }

    constexpr size_type find(const CharT* s, size_type pos, size_type count) const
    {
        return find(basic_string_view(s, count), pos);
    }

    constexpr size_type find(const CharT* s, size_type pos = 0) const
    {
        return find(basic_string_view(s), pos);
    }

    constexpr size_type rfind(basic_string_view v, size_type pos = npos) const noexcept
    {
        if (v.m_size == 0) {
            return pos < m_size ? pos : m_size;
        }
        if (v.m_size > m_size) {
            return npos;
        }
        size_type start = std::min(pos, m_size - v.m_size);
        for (size_type i = start + 1; i-- > 0;) {
            if (traits_type::compare(m_str + i, v.m_str, v.m_size) == 0) {
                return i;
            }
        }
        return npos;
    }

    constexpr size_type rfind(CharT ch, size_type pos = npos) const noexcept
    {
        if (m_size == 0) {
            return npos;
        }
        size_type start = std::min(pos, m_size - 1);
        const_pointer result = traits_type::find(m_str, start + 1, ch);
        if (result != nullptr) {
            return static_cast<size_type>(result - m_str);
        }
        return npos;
    }

    constexpr size_type rfind(const CharT* s, size_type pos, size_type count) const
    {
        return rfind(basic_string_view(s, count), pos);
    }

    constexpr size_type rfind(const CharT* s, size_type pos = npos) const
    {
        return rfind(basic_string_view(s), pos);
    }

public:
    // Operators
    // ^^^^^^

    constexpr const_reference operator[](size_type pos) const noexcept
    {
        return m_str[pos];
    }

private:
    const_pointer m_str;
    size_type m_size;
};

using string_view = basic_string_view<char>;

template <class CharT, class Traits>
constexpr bool operator==(
  std::basic_string_view<CharT, Traits> lhs,
  std::type_identity_t<std::basic_string_view<CharT, Traits>> rhs
) noexcept
{
    return lhs.compare(rhs) == 0;
}

} // namespace std