#pragma once

#include <array>
#include <cassert>
#include <iterator>
#include <limits>
#include <memory>

namespace std
{

inline constexpr std::size_t dynamic_extent = std::numeric_limits<std::size_t>::max();

template <class T, std::size_t Extent = dynamic_extent>
class span;

template <class T>
class span<T, dynamic_extent>
{
public:
    // Type Aliases
    // ^^^^^^

    using element_type = T;
    using value_type = std::remove_cv_t<T>;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using pointer = T*;
    using const_pointer = const T*;
    using reference = T&;
    using const_reference = const T&;

    // Use pointer as iterator type for now
    using iterator = pointer;
    using const_iterator = const_pointer;

private:
    // Instance Variables
    // ^^^^^^

    pointer m_data;
    size_type m_size;

public:
    // Static Variables
    // ^^^^^^

    static constexpr size_type extent = dynamic_extent;

public:
    // Structors
    // ^^^^^^

    constexpr span() noexcept
      : m_data(nullptr)
      , m_size(0)
    {
    }

    template <class It>
    constexpr span(It first, size_type count) noexcept
      : m_data(std::addressof(*first))
      , m_size(count)
    {
    }

    template <class It, class End>
    constexpr span(It first, End last) noexcept
      : m_data(std::addressof(*first))
      , m_size(std::distance(first, last))
    {
    }

    template <std::size_t N>
    constexpr span(std::type_identity<element_type>::type (&arr)[N]) noexcept
      : m_data(arr)
      , m_size(N)
    {
    }

    template <class U, std::size_t N>
    constexpr span(std::array<U, N>& arr) noexcept
      : m_data(arr.data())
      , m_size(N)
    {
    }

    template <class U, std::size_t N>
    constexpr span(const std::array<U, N>& arr) noexcept
      : m_data(arr.data())
      , m_size(N)
    {
    }

public:
    // Instance Methods
    // ^^^^^^

    constexpr pointer data() const noexcept
    {
        return m_data;
    }

    constexpr size_type size() const noexcept
    {
        return m_size;
    }

    constexpr size_type size_bytes() const noexcept
    {
        return m_size * sizeof(element_type);
    }

    constexpr iterator begin() const noexcept
    {
        return m_data;
    }

    constexpr iterator end() const noexcept
    {
        return m_data + m_size;
    }

    constexpr reference at(size_type index) const
    {
        assert(index < m_size);
        return m_data[index];
    }

    constexpr reference operator[](size_type idx) const
    {
        return at(idx);
    }

    constexpr reference front() const
    {
        return at(0);
    }

    constexpr reference back() const
    {
        return at(m_size - 1);
    }

    constexpr span<element_type, dynamic_extent>
    subspan(size_type offset = 0, size_type count = dynamic_extent) const
    {
        if (count == dynamic_extent) {
            count = m_size - offset;
        }

        return span<element_type, dynamic_extent>(m_data + offset, count);
    }
};

} // namespace std