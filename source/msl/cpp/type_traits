#pragma once

#include "cstddef"

namespace std
{

// Internal Macros
// ^^^^^^

#define __trait_predicate_c(__type, __name, __predicate)                                           \
    template <class T>                                                                             \
    struct __name : integral_constant<__type, __predicate> {                                       \
    };                                                                                             \
    template <class T>                                                                             \
    constexpr __type __name##_v = __name<T>::value

#define __trait_predicate_cc(__type, __name, __predicate)                                          \
    template <class T, class U>                                                                    \
    struct __name : integral_constant<__type, __predicate> {                                       \
    };                                                                                             \
    template <class T, class U>                                                                    \
    constexpr __type __name##_v = __name<T, U>::value

#define __trait_predicate_cu(__type, __name, __predicate)                                          \
    template <class T, unsigned N = 0>                                                             \
    struct __name : integral_constant<__type, __predicate> {                                       \
    };                                                                                             \
    template <class T, unsigned N = 0>                                                             \
    constexpr __type __name##_v = __name<T, N>::value

#define __trait_identity(__name)                                                                   \
    template <class T>                                                                             \
    struct __name {                                                                                \
        using type = T;                                                                            \
    };                                                                                             \
    template <class T>                                                                             \
    using __name##_t = typename __name<T>::type

#define __trait_expression(__name, ...)                                                            \
    template <class T>                                                                             \
    struct __name {                                                                                \
        using type = __VA_ARGS__;                                                                  \
    };                                                                                             \
    template <class T>                                                                             \
    using __name##_t = typename __name<T>::type

#define __trait_custom_expression(__name, __expression, ...)                                       \
    struct __name __VA_ARGS__ {                                                                    \
        using type = __expression;                                                                 \
    }

#define __trait_transform_expression(__name, __expression, ...)                                    \
    template <class T>                                                                             \
    __trait_custom_expression(__name, __expression, __VA_ARGS__)

#define __trait_transform(__name, ...) __trait_transform_expression(__name, T, __VA_ARGS__)

// Helper Classes
// ^^^^^^

template <class T, T v>
struct integral_constant {
    static constexpr T value = v;
    using value_type = T;
    using type = integral_constant<T, v>;

    constexpr operator value_type() const noexcept
    {
        return value;
    }
};

template <bool B>
using bool_constant = integral_constant<bool, B>;
using true_type = bool_constant<true>;
using false_type = bool_constant<false>;

// Const-volatility Specifiers
// ^^^^^^

__trait_identity(remove_cv);
__trait_transform(remove_cv, <const T>);
__trait_transform(remove_cv, <volatile T>);
__trait_transform(remove_cv, <const volatile T>);

__trait_identity(remove_const);
__trait_transform(remove_const, <const T>);

__trait_identity(remove_volatile);
__trait_transform(remove_volatile, <volatile T>);

__trait_expression(add_cv, const volatile T);
__trait_expression(add_const, const T);
__trait_expression(add_volatile, volatile T);

// References
// ^^^^^^

__trait_identity(remove_reference);
__trait_transform(remove_reference, <T&>);
__trait_transform(remove_reference, <T&&>);

// add_lvalue_reference, add_rvalue_reference defined later

// Pointers
// ^^^^^^

__trait_identity(remove_pointer);
__trait_transform(remove_pointer, <T*>);
__trait_transform(remove_pointer, <T* const>);
__trait_transform(remove_pointer, <T* volatile>);
__trait_transform(remove_pointer, <T* const volatile>);

__trait_expression(add_pointer, T*);

// Arrays
// ^^^^^^

__trait_identity(remove_extent);
__trait_transform(remove_extent, <T[]>);
template <class T, size_t N>
__trait_custom_expression(remove_extent, T, <T[N]>);

// Miscellaneous Transformations
// ^^^^^^

__trait_expression(remove_cvref, remove_cv_t<remove_reference_t<T>>);

template <bool B, class T = void>
struct enable_if {
};

template <bool B, class T, class F>
__trait_custom_expression(conditional, T);
template <class T, class F>
__trait_custom_expression(conditional, F, <false, T, F>);
template <bool B, class T, class F>
using conditional_t = typename conditional<B, T, F>::type;

__trait_transform(enable_if, <true, T>);
template <bool B, class T = void>
using enable_if_t = typename enable_if<B, T>::type;

template <class...>
using void_t = void;

__trait_expression(underlying_type, __underlying_type(T));
__trait_identity(type_identity);

__trait_expression(
  decay, //
  conditional_t<
    __is_array(T), add_pointer_t<remove_extent_t<remove_reference_t<T>>>,
    conditional_t<
      __is_function(remove_reference_t<T>), add_pointer_t<remove_reference_t<T>>,
      remove_cvref_t<T>>>
);

// Primary Types
// ^^^^^^

__trait_predicate_c(bool, is_void, __is_same_as(void, remove_cv_t<T>));
__trait_predicate_c(bool, is_null_pointer, __is_same_as(nullptr_t, remove_cv_t<T>));
__trait_predicate_c(bool, is_integral, __is_integral(T));
__trait_predicate_c(bool, is_floating_point, __is_floating_point(T));
__trait_predicate_c(bool, is_array, __is_array(T));
__trait_predicate_c(bool, is_enum, __is_enum(T));
__trait_predicate_c(bool, is_union, __is_union(T));
__trait_predicate_c(bool, is_class, __is_class(T));
__trait_predicate_c(bool, is_function, __is_function(T));
__trait_predicate_c(bool, is_pointer, __is_pointer(T));
__trait_predicate_c(bool, is_lvalue_reference, __is_lvalue_reference(T));
__trait_predicate_c(bool, is_rvalue_reference, __is_rvalue_reference(T));
__trait_predicate_c(bool, is_member_object_pointer, __is_member_object_pointer(T));
__trait_predicate_c(bool, is_member_function_pointer, __is_member_function_pointer(T));

// Composite Types
// ^^^^^^

__trait_predicate_c(bool, is_fundamental, __is_fundamental(T));
__trait_predicate_c(bool, is_arithmetic, __is_arithmetic(T));
__trait_predicate_c(bool, is_scalar, __is_scalar(T));
__trait_predicate_c(bool, is_object, __is_object(T));
__trait_predicate_c(bool, is_compound, __is_compound(T));
__trait_predicate_c(bool, is_reference, __is_reference(T));
__trait_predicate_c(bool, is_member_pointer, __is_member_pointer(T));

// Type Properties
// ^^^^^^

__trait_predicate_c(bool, is_const, __is_const(T));
__trait_predicate_c(bool, is_volatile, __is_volatile(T));
__trait_predicate_c(bool, is_trivial, __is_trivial(T));
__trait_predicate_c(bool, is_trivially_copyable, __is_trivially_copyable(T));
__trait_predicate_c(bool, is_standard_layout, __is_standard_layout(T));
__trait_predicate_c(bool, is_pod, __is_pod(T));
__trait_predicate_c(bool, is_literal_type, __is_literal_type(T));
__trait_predicate_c(
  bool, has_unique_object_representations, __has_unique_object_representations(T)
);
__trait_predicate_c(bool, is_empty, __is_empty(T));
__trait_predicate_c(bool, is_polymorphic, __is_polymorphic(T));
__trait_predicate_c(bool, is_abstract, __is_abstract(T));
__trait_predicate_c(bool, is_final, __is_final(T));
__trait_predicate_c(bool, is_aggregate, __is_aggregate(T));
// __trait_predicate_c(bool, is_implicit_lifetime, __builtin_is_implicit_lifetime(T)); // Not
// implemented in current Clang version
__trait_predicate_c(bool, is_signed, __is_signed(T));
__trait_predicate_c(bool, is_unsigned, __is_unsigned(T));
__trait_predicate_c(bool, is_bounded_array, __is_bounded_array(T));
__trait_predicate_c(bool, is_unbounded_array, __is_unbounded_array(T));
__trait_predicate_c(bool, is_scoped_enum, __is_scoped_enum(T));

// References
// ^^^^^^

__trait_expression(add_lvalue_reference, conditional_t<is_void_v<T>, T, T&>);
__trait_expression(add_rvalue_reference, conditional_t<is_void_v<T>, T, T&&>);

// Supported Operations
// ^^^^^^

template <class T, class... Args>
struct is_constructible : integral_constant<bool, __is_constructible(T, Args...)> {
};
template <class T, class... Args>
constexpr bool is_constructible_v = is_constructible<T, Args...>::value;

template <class T, class... Args>
struct is_trivially_constructible
  : integral_constant<bool, __is_trivially_constructible(T, Args...)> {
};
template <class T, class... Args>
constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;

template <class T, class... Args>
struct is_nothrow_constructible : integral_constant<bool, __is_nothrow_constructible(T, Args...)> {
};
template <class T, class... Args>
constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<T, Args...>::value;

__trait_predicate_c(bool, is_default_constructible, is_constructible_v<T>);
__trait_predicate_c(bool, is_trivially_default_constructible, is_trivially_constructible_v<T>);
__trait_predicate_c(bool, is_nothrow_default_constructible, is_nothrow_constructible_v<T>);

__trait_predicate_c(bool, is_copy_constructible, (is_constructible_v<T, const T&>) );
__trait_predicate_c(
  bool, is_trivially_copy_constructible, (is_trivially_constructible_v<T, const T&>)
);
__trait_predicate_c(
  bool, is_nothrow_copy_constructible, (is_nothrow_constructible_v<T, const T&>)
);

__trait_predicate_c(bool, is_move_constructible, (is_constructible_v<T, T&&>) );
__trait_predicate_c(bool, is_trivially_move_constructible, (is_trivially_constructible_v<T, T&&>) );
__trait_predicate_c(bool, is_nothrow_move_constructible, (is_nothrow_constructible_v<T, T&&>) );

__trait_predicate_cc(bool, is_assignable, __is_assignable(T, U));
__trait_predicate_cc(bool, is_trivially_assignable, __is_trivially_assignable(T, U));
__trait_predicate_cc(bool, is_nothrow_assignable, __is_nothrow_assignable(T, U));

__trait_predicate_c(bool, is_copy_assignable, (is_assignable_v<T, const T&>) );
__trait_predicate_c(bool, is_trivially_copy_assignable, (is_trivially_assignable_v<T, const T&>) );
__trait_predicate_c(bool, is_nothrow_copy_assignable, (is_nothrow_assignable_v<T, const T&>) );

__trait_predicate_c(bool, is_move_assignable, (is_assignable_v<T, T&&>) );
__trait_predicate_c(bool, is_trivially_move_assignable, (is_trivially_assignable_v<T, T&&>) );
__trait_predicate_c(bool, is_nothrow_move_assignable, (is_nothrow_assignable_v<T, T&&>) );

__trait_predicate_c(bool, is_destructible, __is_destructible(T));
__trait_predicate_c(bool, is_trivially_destructible, __is_trivially_destructible(T));
__trait_predicate_c(bool, is_nothrow_destructible, __is_nothrow_destructible(T));

__trait_predicate_c(bool, has_virtual_destructor, __has_virtual_destructor(T));

// Property Queries
// ^^^^^^

__trait_predicate_c(size_t, alignment_of, alignof(T));
__trait_predicate_c(size_t, rank, __array_rank(T));
__trait_predicate_cu(size_t, extent, __array_extent(T, N));

// Type Relationships
// ^^^^^^

__trait_predicate_cc(bool, is_same, __is_same_as(T, U));
__trait_predicate_cc(bool, is_base_of, __is_base_of(T, U));

#undef __trait_predicate_c
#undef __trait_predicate_cc
#undef __trait_predicate_cu
#undef __trait_identity
#undef __trait_expression
#undef __trait_custom_expression
#undef __trait_transform_expression
#undef __trait_transform

} // namespace std
