#pragma once

#include <cstddef>
#include <limits>
#include <memory>
#include <type_traits>

namespace std
{

template <class T, class Allocator = std::allocator<T>>
class vector
{
    static_assert(
      std::is_copy_assignable_v<T> && std::is_copy_constructible_v<T>,
      "std::vector requires T to be copyable"
    );

public:
    // Type Aliases
    // ^^^^^^

    using value_type = T;
    using allocator_type = Allocator;
    using size_type = std::size_t;
    using difference_type = std::ptrdiff_t;
    using reference = T&;
    using const_reference = const T&;
    using pointer = typename std::allocator_traits<Allocator>::pointer;
    using const_pointer = typename std::allocator_traits<Allocator>::const_pointer;

private:
    // Instance Variables
    // ^^^^^^

    pointer m_data = nullptr;
    std::size_t m_size = 0;
    std::size_t m_capacity = 0;
    allocator_type m_allocator;

public:
    // Structors
    // ^^^^^^

    constexpr vector() noexcept(noexcept(allocator_type()))
      : vector(allocator_type())
    {
    }

    explicit constexpr vector(const allocator_type& alloc) noexcept
      : m_allocator(alloc)
    {
    }

    vector(size_type count, const value_type& value, const allocator_type& alloc = allocator_type())
      : m_allocator(alloc)
    {
        resize(count, value);
    }

public:
    // Instance Methods
    // ^^^^^^

    constexpr reference at(size_type pos)
    {
        if (pos >= m_size) {
            __builtin_trap();
        }
        return m_data[pos];
    }

    constexpr const_reference at(size_type pos) const
    {
        if (pos >= m_size) {
            __builtin_trap();
        }
        return m_data[pos];
    }

    constexpr reference operator[](size_type pos)
    {
        return m_data[pos];
    }

    constexpr const_reference operator[](size_type pos) const
    {
        return m_data[pos];
    }

    constexpr reference front()
    {
        return m_data[0];
    }

    constexpr const_reference front() const
    {
        return m_data[0];
    }

    constexpr reference back()
    {
        return m_data[m_size - 1];
    }

    constexpr const_reference back() const
    {
        return m_data[m_size - 1];
    }

    pointer data() noexcept
    {
        return m_data;
    }

    constexpr bool empty() const noexcept
    {
        return m_size == 0;
    }

    constexpr size_type size() const noexcept
    {
        return m_size;
    }

    constexpr size_type max_size() const noexcept
    {
        return std::numeric_limits<difference_type>::max();
    }

    constexpr void reserve(size_type new_cap)
    {
        if (new_cap <= m_capacity) {
            return;
        }
        pointer new_data = std::allocator_traits<allocator_type>::allocate(m_allocator, new_cap);
        for (size_type i = 0; i < m_size; i++) {
            std::allocator_traits<allocator_type>::construct(
              m_allocator, new_data + i, std::move_if_noexcept(m_data[i])
            );
            std::allocator_traits<allocator_type>::destroy(m_allocator, m_data + i);
        }
        if (m_data) {
            std::allocator_traits<allocator_type>::deallocate(m_allocator, m_data, m_capacity);
        }
        m_data = new_data;
        m_capacity = new_cap;
    }

    constexpr size_type capacity() const noexcept
    {
        return m_capacity;
    }

    constexpr void push_back(const value_type& value)
    {
        if (m_size == m_capacity) {
            reserve(m_capacity > 0 ? m_capacity * 2 : 1);
        }
        std::allocator_traits<allocator_type>::construct(m_allocator, m_data + m_size, value);
        m_size++;
    }

    constexpr void push_back(value_type&& value)
    {
        if (m_size == m_capacity) {
            reserve(m_capacity > 0 ? m_capacity * 2 : 1);
        }
        std::allocator_traits<allocator_type>::construct(
          m_allocator, m_data + m_size, std::move(value)
        );
        m_size++;
    }

    template <class... Args>
    constexpr reference emplace_back(Args&&... args)
    {
        if (m_size == m_capacity) {
            reserve(m_capacity > 0 ? m_capacity * 2 : 1);
        }
        std::allocator_traits<allocator_type>::construct(
          m_allocator, m_data + m_size, std::forward<Args>(args)...
        );
        m_size++;
        return m_data[m_size - 1];
    }

    constexpr void pop_back()
    {
        if (m_size == 0) {
            return;
        }
        m_size--;
        std::allocator_traits<allocator_type>::destroy(m_allocator, m_data + m_size);
    }

    constexpr void resize(size_type count, const value_type& value)
    {
        if (count > m_capacity) {
            reserve(count);
        }
        for (size_type i = m_size; i < count; i++) {
            std::allocator_traits<allocator_type>::construct(m_allocator, m_data + i, value);
        }
        for (size_type i = count; i < m_size; i++) {
            std::allocator_traits<allocator_type>::destroy(m_allocator, m_data + i);
        }
        m_size = count;
    }

    constexpr void clear() noexcept
    {
        for (size_type i = 0; i < m_size; i++) {
            std::allocator_traits<allocator_type>::destroy(m_allocator, m_data + i);
        }
        m_size = 0;
    }
};

} // namespace std