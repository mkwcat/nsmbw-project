#pragma once

#include <cassert>
#include <concepts>
#include <cstddef>
#include <memory>
#include <type_traits>
#include <utility>

namespace std
{

namespace __
{
struct differentiate_mangled {
};
} // namespace __

template <class... Types>
class variant;

inline constexpr size_t variant_npos = -1;

template <size_t I, class T>
struct variant_alternative;

template <size_t I, class T>
using variant_alternative_t = typename variant_alternative<I, T>::type;

template <class... Types>
class variant
{
    template <size_t I, class T>
    friend struct variant_alternative;

    template <size_t I, class... _Types>
    friend constexpr variant_alternative_t<I, variant<_Types...>>& get(variant<_Types...>& v);

    template <size_t I, class... _Types>
    friend constexpr variant_alternative_t<I, variant<_Types...>>&& get(variant<_Types...>&& v);

    template <size_t I, class... _Types>
    friend constexpr const variant_alternative_t<I, variant<_Types...>>&
    get(const variant<_Types...>& v);

    template <size_t I, class... _Types>
    friend constexpr const variant_alternative_t<I, variant<_Types...>>&&
    get(const variant<_Types...>&& v, __::differentiate_mangled);

    template <class T, class... _Types>
    friend constexpr T& get(variant<_Types...>& v);

    template <class T, class... _Types>
    friend constexpr T&& get(variant<_Types...>&& v, __::differentiate_mangled);

    template <class T, class... _Types>
    friend constexpr const T& get(const variant<_Types...>& v);

    template <class T, class... _Types>
    friend constexpr const T&& get(const variant<_Types...>&& v, __::differentiate_mangled);

    template <class T, class... _Types>
    friend constexpr bool holds_alternative(const variant<_Types...>& v) noexcept;

    template <class... _Types>
    friend constexpr bool
    operator==(const std::variant<_Types...>& lhs, const std::variant<_Types...>& rhs);

private:
    // Instance Variables
    // ^^^^^^

    template <size_t... Sizes>
    static consteval size_t max_size() noexcept
    {
        size_t sizes[] = {Sizes...};
        size_t max_size = 0;
        for (size_t size : sizes) {
            if (size > max_size) {
                max_size = size;
            }
        }
        return max_size;
    }

    size_t m_index;
    alignas(Types...) u8 m_storage[max_size<sizeof(Types)...>()];

private:
    // Private Utility Methods
    // ^^^^^^

    template <size_t I>
    constexpr auto* get_storage() noexcept
    {
        static_assert(I < sizeof...(Types), "Variant index out of range");
        return static_cast<Types...[I]*>(static_cast<void*>(&m_storage));
    }

    template <size_t I>
    constexpr const auto* get_const_storage() const noexcept
    {
        static_assert(I < sizeof...(Types), "Variant index out of range");
        return static_cast<const Types...[I]*>(static_cast<const void*>(&m_storage));
    }

    template <class T, size_t... Indices>
    static consteval size_t get_index_of(index_sequence<Indices...>)
    {
        size_t index = variant_npos;
        ((is_same_v<T, Types...[Indices]> && index == variant_npos && (index = Indices)), ...);
        return index;
    }

    template <class T, class F>
    static constexpr bool is_constructible_from = requires(F f) { T{f}; };

    template <class T, size_t... Indices>
    static consteval size_t get_constructible_index(index_sequence<Indices...>)
    {
        size_t index = variant_npos;
        ((is_constructible_from<Types...[Indices], T> && index == variant_npos &&
          (index = Indices)),
         ...);
        return index;
    }

    template <size_t... Indices>
    constexpr void construct(const variant& other, index_sequence<Indices...>)
    {
        m_index = other.m_index;
        ((other.m_index == Indices &&
          construct_at(get_storage<Indices>(), *other.get_const_storage<Indices>())),
         ...);
    }

    template <size_t... Indices>
    constexpr void construct(variant&& other, index_sequence<Indices...>)
    {
        m_index = other.m_index;
        ((other.m_index == Indices &&
          construct_at(get_storage<Indices>(), move(*other.get_storage<Indices>()))),
         ...);
    }

    template <class T, size_t... Indices>
    constexpr void construct(T&& t)
    {
        constexpr size_t index =
          get_constructible_index<T&&>(make_index_sequence<sizeof...(Types)>());
        static_assert(
          index != variant_npos, "Type is not constructible into any of the variant's alternatives"
        );
        m_index = index;
        construct_at(get_storage<index>(), forward<T>(t));
    }

    template <size_t I>
    constexpr bool equals_by_index(const variant& other) const
    {
        if constexpr (is_same_v<monostate, Types...[I]>) {
            return true;
        }

        constexpr bool equallable = requires(const Types...[I] & a, const Types...[I] & b) {
            { a == b } -> convertible_to<bool>;
        };
        if constexpr (equallable) {
            return *get_const_storage<I>() == *other.get_const_storage<I>();
        } else {
            return false;
        }
    }

    template <size_t... Indices>
    constexpr bool equals(const variant& other, index_sequence<Indices...>) const
    {
        if (index() != other.index()) {
            return false;
        }
        if (index() == variant_npos) {
            return true;
        }

        bool result = true;
        ((m_index == Indices && (result = equals_by_index<Indices>(other))), ...);
        return result;
    }

public:
    // Structors
    // ^^^^^^

    constexpr variant() noexcept
      : m_index(0)
    {
        construct_at(get_storage<0>());
    }

    constexpr variant(const variant& other) noexcept
    {
        construct(other, make_index_sequence<sizeof...(Types)>());
    }

    constexpr variant(variant&& other) noexcept
    {
        construct(move(other), make_index_sequence<sizeof...(Types)>());
    }

    template <class T>
        requires(not same_as<remove_cvref_t<T>, variant<Types...>>)
    constexpr variant(T&& t) noexcept
    {
        construct<T>(forward<T>(t));
    }

    constexpr variant& operator=(const variant& rhs)
    {
        construct(rhs, make_index_sequence<sizeof...(Types)>());
        return *this;
    }

    constexpr variant& operator=(variant&& rhs)
    {
        construct(move(rhs), make_index_sequence<sizeof...(Types)>());
        return *this;
    }

    constexpr size_t index() const noexcept
    {
        return m_index;
    }
};

template <size_t I, class T>
struct variant_alternative<I, const T> : add_const<variant_alternative_t<I, T>> {
};

template <size_t I, class... Types>
struct variant_alternative<I, variant<Types...>> {
    using type = Types...[I];
};

template <size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>& get(variant<Types...>& v)
{
    static_assert(I < sizeof...(Types), "Variant index out of range");
    assert(v.index() == I);
    return *v.template get_storage<I>();
}

template <size_t I, class... Types>
constexpr variant_alternative_t<I, variant<Types...>>&&
get(variant<Types...>&& v, __::differentiate_mangled = {})
{
    static_assert(I < sizeof...(Types), "Variant index out of range");
    assert(v.index() == I);
    return std::move(*v.template get_storage<I>());
}

template <size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>& get(const variant<Types...>& v)
{
    static_assert(I < sizeof...(Types), "Variant index out of range");
    assert(v.index() == I);
    return *v.template get_const_storage<I>();
}

template <size_t I, class... Types>
constexpr const variant_alternative_t<I, variant<Types...>>&&
get(const variant<Types...>&& v, __::differentiate_mangled = {})
{
    static_assert(I < sizeof...(Types), "Variant index out of range");
    assert(v.index() == I);
    return std::move(*v.template get_const_storage<I>());
}

template <class T, class... Types>
constexpr T& get(variant<Types...>& v)
{
    constexpr size_t index =
      variant<Types...>::template get_index_of<T>(make_index_sequence<sizeof...(Types)>());
    static_assert(index != variant_npos, "Type is not in variant");
    return get<index>(v);
}

template <class T, class... Types>
constexpr T&& get(variant<Types...>&& v, __::differentiate_mangled = {})
{
    constexpr size_t index =
      variant<Types...>::template get_index_of<T>(make_index_sequence<sizeof...(Types)>());
    static_assert(index != variant_npos, "Type is not in variant");
    assert(v.index() == index);
    return std::move(*v.template get_storage<index>());
}

template <class T, class... Types>
constexpr const T& get(const variant<Types...>& v)
{
    constexpr size_t index =
      variant<Types...>::template get_index_of<T>(make_index_sequence<sizeof...(Types)>());
    static_assert(index != variant_npos, "Type is not in variant");
    assert(v.index() == index);
    return *v.template get_const_storage<index>();
}

template <class T, class... Types>
constexpr const T&& get(const variant<Types...>&& v, __::differentiate_mangled = {})
{
    constexpr size_t index =
      variant<Types...>::template get_index_of<T>(make_index_sequence<sizeof...(Types)>());
    static_assert(index != variant_npos, "Type is not in variant");
    assert(v.index() == index);
    return std::move(*v.template get_const_storage<index>());
}

template <class T, class... Types>
constexpr bool holds_alternative(const std::variant<Types...>& v) noexcept
{
    constexpr size_t index =
      variant<Types...>::template get_index_of<T>(make_index_sequence<sizeof...(Types)>());
    static_assert(index != variant_npos, "Type is not in variant");
    return v.index() == index;
}

template <class... Types>
constexpr bool operator==(const std::variant<Types...>& lhs, const std::variant<Types...>& rhs)
{
    return lhs.equals(rhs, make_index_sequence<sizeof...(Types)>());
}

static_assert(
  sizeof(variant<double>) == sizeof(variant<monostate, char, short, int, long, long long, double>)
);

} // namespace std