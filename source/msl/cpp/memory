#pragma once

#include <cstddef>
#include <new>
#include <type_traits>
#include <utility>

namespace std
{

template <class T, class... Args>
constexpr T* construct_at(T* location, Args&&... args)
{
    return ::new (static_cast<void*>(location)) T(std::forward<Args>(args)...);
}

template <class T>
struct allocator {
    using value_type = T;
    using size_type = size_t;
    using difference_type = ptrdiff_t;
    using propagate_on_container_move_assignment = true_type;

    allocator() = default;

    template <class U>
    allocator(const allocator<U>&)
    {
    }

    ~allocator() = default;

    T* allocate(size_t n)
    {
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }

    void deallocate(T* p, size_t) noexcept
    {
        ::operator delete(p);
    }
};

template <class Alloc>
struct allocator_traits {
private:
    template <class A>
    static auto get_pointer(int) -> decltype(typename A::pointer{});
    template <class A>
    static auto get_pointer(...) -> typename A::value_type*;

    template <class A>
    static auto get_const_pointer(int) -> decltype(typename A::const_pointer{});
    template <class A>
    static auto get_const_pointer(...) -> const typename A::value_type*;

public:
    // Type Aliases
    // ^^^^^^

    using allocator_type = Alloc;
    using value_type = typename Alloc::value_type;
    using pointer = decltype(get_pointer<Alloc>(0));
    using const_pointer = decltype(get_const_pointer<Alloc>(0));

public:
    // Static Methods
    // ^^^^^^

    static constexpr pointer allocate(allocator_type& alloc, size_t n)
    {
        return alloc.allocate(n);
    }

    static constexpr void deallocate(allocator_type& alloc, pointer p, size_t n)
    {
        alloc.deallocate(p, n);
    }

    template <class T, class... Args>
    static constexpr void construct(allocator_type& alloc, T* p, Args&&... args)
    {
        std::construct_at(p, std::forward<Args>(args)...);
    }

    template <class T>
    static constexpr void destroy(allocator_type& alloc, T* p)
    {
        p->~T();
    }
};

} // namespace std